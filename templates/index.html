<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>trvl plnnr</title>
  <link rel="stylesheet" href="/packages/bootstrap-reboot.min.css">
  <link rel="stylesheet" href="/packages/bootstrap-grid.min.css">
  <link rel="stylesheet" href="/packages/bootstrap-utilities.min.css">
  <link rel="stylesheet" href="/packages/bootstrap.min.css">
  <script src="/packages/bootstrap.bundle.min.js"></script>
  <script src="/packages/Sortable.min.js"></script>
  <style>
    body {
      background: #75C2F6;
    }
    [id^='day-'] {
      background: #FFEADD;
    }
    .card {
      max-height: 10rem;
      overflow: hidden;
    }
    .card img {
      /* Make image always fill the box and adjust its size on mobile */
      height: 100%;
      width: 100%;
      object-fit: cover;
      /* Have the corners of the images match the rounding of the card */
      border-top-right-radius: 0;
      border-top-left-radius: calc(0.25rem - 1px);
      border-bottom-left-radius: calc(0.25rem - 1px);
    }
    .card-title {
      font-weight: bold;
      /* Set the height to limit text length of titles */
      height: 3.5rem;
      overflow: hidden;
    }
    .dragging {
      background: #1D5D9B;
      color: white;
    }
  </style>
</head>
<body>
  <!-- Title header -->
  <header>
    <h1 class="display-4 text-white text-center mt-1">trvl plnnr</h1>
  </header>
  <!-- Modal popup -->
  <div class="modal fade" id="exampleModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h1 class="modal-title fs-5" id="exampleModalLabel">Remove Event</h1>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <fieldset>
            <legend>How should this event be removed?</legend>
            <div>
              <input type="radio" id="fill" name="drone" value="fill"
                     checked>
              <label class="ps-2" for="fill">Fill with a "Free Time" event</label>
            </div>
            <div>
              <input type="radio" id="morePrev" name="drone" value="morePrev">
              <label class="ps-2" for="morePrev">Spend more time at the previous location</label>
            </div>
            <div>
              <input type="radio" id="moreNext" name="drone" value="moreNext">
              <label class="ps-2" for="moreNext">Spend more time at the next location</label>
            </div>
        </fieldset>        
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          <button type="button" class="btn btn-primary">Remove Event</button>
        </div>
      </div>
    </div>
  </div>  
  {% block list %}
  {% endblock list %}
  <script>
    let startingSortables = []
    for (let index = 0; index < 3; index++) {
      const dayList = document.getElementById("day-"+index)
      let sortableInstance = Sortable.create(dayList, {
        group: {
          name: "shared",
          pull: "clone",
          revertClone: true, // This is needed so that clone doesn't jump around in the orig list
        },
        draggable: ".card",
        animation: 150,
        ghostClass: "dragging",
        store: {
          // Called onEnd, when any item is dropped
          // If moving between groups, gives sortable for new list, then old list
          set: function (sortable) {
            console.log(sortable.toArray())
            // Check which of original list has at least 2 matches
          },
        },
        onClone: function(event) {
          makeCardFreeTime(event.clone)
        }
        // onEnd: function(event) { 
        // }
      });
      startingSortables.push(sortableInstance.toArray())
    }

    function makeCardFreeTime(cardElement) {
      cardElement.dataset.id = "Free Time"
      cardElement.querySelector(".img-fluid").src = "/images/paris/free.jpg"
      cardElement.querySelector(".card-title").innerHTML = "Free Time"
      cardElement.querySelector(".card-text").innerHTML = "Do whatever you want"
    }

    // function getCardElement(dataset, desiredElement) {
    //   // Example input: ([data-day='1'][data-index='1'].siteName")
    //   return document.querySelector(`
    //   [data-day='${dataset.day}'][data-index='${dataset.index}']${desiredElement}
    //   `)
    // }

    // function getPreviousListItemElement(dataset, desiredElement) {
    //   newDataSet = {
    //     day: dataset.day,
    //     index: (parseInt(dataset.index)-1).toString()
    //   }
    //   return getSiblingElement(newDataSet, desiredElement)
    // }

    // function getNextListItemElement(dataset, desiredElement) {
    //   newDataSet = {
    //     day: dataset.day,
    //     index: (parseInt(dataset.index)+1).toString()
    //   }
    //   return getSiblingElement(newDataSet, desiredElement)
    // }

    // let sortableInstance
    // const lists = document.getElementsByClassName('list');
    // // THIS MUST REMAIN "OF"
    // for (const list of lists) {
    //   sortableInstance = Sortable.create(list, {
    //     group: {
    //       name: "list",
    //       pull: "clone",
    //       revertClone: true, // This is needed so that clone doesn't jump around in the orig list
    //     },
    //     draggable: ".listItem",
    //     delay: 400,
    //     // We really only need delay on mobile to allow dragging
    //     // and this works around a bug that prevents delays on Edge
    //     delayOnTouchOnly: true,
    //     // Needed for delay on some sensitive touch screens
    //     touchStartThreshold: 3,
    //     animation: 150,
    //     dataIdAttr: "data-siteName",
    //     // TODO Update day and index on move
    //     onEnd: function (event) {
    //       // Update day and index on move
    //       event.item.dataset.day = event.to.dataset.day
    //       event.item.dataset.index = event.newIndex

    //       // TODO Update day and index of all other impacted elements

    //       // // Change the clone element (in the original position) to Free Time
    //       // // WARNING Do not use sibling element with clone elements
    //       // event.clone.querySelector(".siteName").innerHTML = "Free Time"
    //       // event.clone.querySelector(".description").innerHTML = "Do whatever you want"

    //       // let duration = getDuration(getSiblingElement(event.item.dataset, ".beginning").value, getSiblingElement(event.item.dataset, ".ending").value)
    //       // // console.log(duration)

    //       // // If moved within the same list
    //       // if (event.from == event.to) {
    //       //   // Move item from top towards bottom
    //       //   if (event.oldIndex < event.newIndex) {

    //       //     // Items between old and new index need to have their times 
    //       //     // subtracted by the duration of the original listItem
    //       //     for (let index = 0; index < event.to.children.length; index++) {
    //       //       if (index >= event.oldIndex && index < event.newIndex) {
    //       //         currentElement = event.to.children[index]
    //       //         currentElement.dataset.index = currentElement.dataset.index - 1
    //       //         // WARNING You need a live element to update the time here, so we cannot assign it a variable first
    //       //         getSiblingElement(currentElement.dataset, ".beginning").value = newTime(getSiblingElement(currentElement.dataset, ".beginning").value, -duration)
    //       //         getSiblingElement(currentElement.dataset, ".ending").value = newTime(getSiblingElement(currentElement.dataset, ".ending").value, -duration)
    //       //       }
    //       //     }
    //       //   } 
    //         // Move item from bottom towards top
    //         // else {

    //         // }

    //         // Change time of the moved element itself,
    //         // Based on the ending and beginning time of its neighbors
            
    //         // Get ending time of previous list item
    //       //   let previousListItemEndingTime = getPreviousListItemElement(event.item.dataset, ".ending").value
    //       //   // Make sure previous ending time exists before trying to change it
    //       //   console.log(previousListItemEndingTime)
    //       //   if (previousListItemEndingTime) {
    //       //     console.log("reached")
    //       //     getSiblingElement(event.item.dataset, ".beginning").value = previousListItemEndingTime
    //       //   }

    //       //   // Get beginning time of next list item
    //       //   let nextListItemBeginningTime = getNextListItemElement(event.item.dataset, ".beginning")
    //       //   // Make sure next beginning time exists before trying to change it
    //       //   if (nextListItemBeginningTime) {
    //       //     getSiblingElement(event.item.dataset, ".ending").value = nextListItemBeginningTime.value
    //       //   }
    //       // }
    //     }
    //   });
    // };

    // // Changes the beginning or ending time of sibling listItems 
    // // if the user changes the ending or beginning time of the current listItem
    // function changeSiblingTimes(event) {
    //   // Change to event beginning time
    //   if (event.target.className == "beginning") {
    //     // Get ending time of previous list item
    //     let previousListItemEndingTime = getPreviousListItemElement(event.target.dataset, ".ending")
    //     // Make sure previous ending time exists before trying to change it
    //     if (previousListItemEndingTime) {
    //       previousListItemEndingTime.value = event.target.value
    //       isDurationPositive(previousListItemEndingTime)
    //     }
    //   }
    //   // Change to event ending time
    //   else {
    //     // Get beginning time of next list item
    //     let nextListItemBeginningTime = getNextListItemElement(event.target.dataset, ".beginning")
    //     // Make sure next beginning time exists before trying to change it
    //     if (nextListItemBeginningTime) {
    //       nextListItemBeginningTime.value = event.target.value
    //       isDurationPositive(nextListItemBeginningTime)
    //     }
    //   }
    // }

    // // Check that the duration of any HTML element makes sense (is positive)
    // function isDurationPositive(element) {
    //   // If the user changed the beginning time, we need to make sure
    //   // it isn't later than the ending time
    //   if (element.className == "beginning") {
    //     endingTime = getSiblingElement(element.dataset, ".ending").value
    //     if (changeTimeToDuration(element.value) > changeTimeToDuration(endingTime)) {
    //       element.parentElement.style.background = "#fa2a55"
    //     } else {
    //       element.parentElement.style.background = "#FCAEAE"
    //     }
    //   }
    //   // If the user changed the ending time, we need to make sure
    //   // it isn't later than the beginning time
    //   else {
    //     beginningTime = getSiblingElement(element.dataset, ".beginning").value
    //     if (changeTimeToDuration(element.value) < changeTimeToDuration(beginningTime)) {
    //       element.parentElement.style.background = "#fa2a55"
    //     } else {
    //       element.parentElement.style.background = "#FCAEAE"
    //     }
    //   }
    // }

    // const times = document.querySelectorAll("input[type=time]");
    // // THIS MUST REMAIN "OF"
    // for (const time of times) {
    //   time.addEventListener("change", (event) => {
    //     changeSiblingTimes(event)
    //     // TODO Check if the duration of the changed sibling is still positive, if not change color
    //     isDurationPositive(event.target)
    //   });
    // }

    // const closes = document.getElementsByClassName('btn-close');
    // // THIS MUST REMAIN "OF"
    // for (const close of closes) {
    //   close.addEventListener("click", (event) => {
    //     thisCard = event.target.closest(".card")
    //     makeCardFreeTime(thisCard)
    //   });
    // }



    // NOW
    // Remove attraction with option for:
      // Fill free time, spend more time at previous site, spend more time at next site
    // Change time when events are dragged:
      // Don't change times, shift earlier sites by duration, shift later sites by duration
    // How do we look on mobile?


    // TODO
    // How to handle both generic descriptions of locations and specific directions for the location
    // Modify start/end time
    // Account for travel, both between sites and at the beginning/end of day
    // When moving to Cloudflare pages, upload images directly
    // Make card height proportional to attraction length, shrinking/growing as needed (floor(time/30min))
    // Optimize bootstrap bundle: https://getbootstrap.com/docs/5.3/customize/optimize/
    // Save state to URL hash
    // Load state from URL hash
    // Handle dates and times more robustly
      // Luxon, Day.js, Date and Intl objects
      // Handle events split across multiple days (e.g. 11pm-1am)
    // Make remove events more spatially aware
      // Auto delete 'Free Time'
      // Detect if beginning or end of list

    </script>
</body>
</html>