<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>JHJ TRVLPLNNR</title>
  <style>
    body {
      margin: 0.5rem;
      /* TODO We can pick a prettier font */
      font: 1.25rem/1.5 sans-serif;
      text-rendering: optimizeSpeed;
      background: #FFEADD;
    }
    .list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .listItem {
      /* TODO The background being a photo of the attraction is also possible,
      but care should be taken to make sure the text is still legible */
      background: #FCAEAE;
      border-radius: 0.5rem;
      border: solid #FF8989;
      padding: 0.5rem;
      /* TODO Make height proportional to lengh, shrink and grow as needed */
      /* Probs sizing per 30min, floored */
      overflow: hidden;
      min-height: 3rem;
      /* cursor: move; */
    }
    .listItem > *, h4 {
      margin: 0;
    }
    .head {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    p {
      font-size: 1rem;
    }
    input[type=time] {
      border: none;
      background: #FF8989;
      color: white;
      border-radius: 0.2rem;
      padding: 0;
    }
    #daypicker {
      /* Do I need to remove the display flex if we have more days? */
      display: flex;
      /* justify-content: space-between; */
      background-color: #FF8989;
      border-radius: 0.5rem;
      margin-bottom: 1rem;
      /* TODO Get back to this for dynamic trip sizes */
      overflow: auto;
      white-space: nowrap;
    }
    #daypicker a {
      display: inline-block;
      cursor: pointer;
      color: white;
      text-align: center;
      padding: 14px;
      text-decoration: none;
      width: 33%;
    }
    #daypicker a:hover {
      background-color: #fa2a55;
    }
    h4, span {
      line-height: normal;
    }
    .close {
      cursor: pointer;
    }
  </style>
</head>
<body>
  <header>
    <h1 style="font-size: 10vw; color: #FF6666; text-align: center; margin: 0;">Travel Planner</h1>
  </header>
  {% block list %}
  {% endblock list %}
  <script src="/Sortable.min.js"></script>
  <script>
    // let state = fetch("/itineraries/paris/3day.json")
    // .then(res => res.json())

    function changeTimeToDuration(time) {
      let splitTime = time.split(":")
      let hours = parseInt(splitTime[0], 10) * 60
      let minutes = parseInt(splitTime[1], 10)

      return hours + minutes
    }

    // Inputs are the raw time values, not ints
    function getDuration(beginningTime, endingTime) {
      return changeTimeToDuration(endingTime) - changeTimeToDuration(beginningTime)
    }

    function changeDurationToTime(duration) {
      let hours = Math.floor(duration / 60).toString();          
      let minutes = (duration % 60).toString();

      return hours.concat(":",minutes)
    }

    // origTime is raw time value, not an int
    // Always adds, if you want subtraction, input a negative duration
    function newTime(origTime, duration) {
      return changeDurationToTime(changeTimeToDuration(origTime) + duration)
    }

    const lists = document.getElementsByClassName('list');
    // THIS MUST REMAIN "OF"
    for (const list of lists) {
      Sortable.create(list, {
        group: {
          name: "list",
          pull: "clone",
          revertClone: true, // This is needed so that clone doesn't pop back in the orig list
        },
        delay: 400,
        // We really only need delay on mobile to allow dragging
        // and this works around a bug that prevents delays on Edge
        delayOnTouchOnly: true,
        // Needed for delay on some sensitive touch screens
        touchStartThreshold: 3,
        // handle: '.handle',
        animation: 150,
        onEnd: function (event) {
          event.clone.children[0].children[0].innerHTML = "Free Time"
          event.clone.children[3].innerHTML = "Do whatever you want"

          // let duration = getDuration(event.item.children[1].value, event.item.children[2].value)

          // // If moved within the same list
          // if (event.from == event.to) {
          //   // Move item from top towards bottom
          //   if (event.oldIndex < event.newIndex) {

          //     for (let index = 0; index < event.to.children.length; index++) {
          //       if (index >= event.oldIndex && index < event.newIndex) {
          //         // Items between old and new index need to have their times 
          //         // subtracted by the duration of the original listItem
          //         console.log(duration)
          //         console.log(event.to.children[index].children[1].value)
          //         console.log(event.to.children[index].children[2].value)
          //         console.log(newTime(event.to.children[index].children[1].value, -duration))
          //         console.log(newTime(event.to.children[index].children[2].value, -duration))
          //         event.to.children[index].children[1].value = newTime(event.to.children[index].children[1].value, -duration)
          //         event.to.children[index].children[2].value = newTime(event.to.children[index].children[2].value, -duration)
          //       }
          //     }
          //   } 
            // Move item from bottom towards top
            // else {

            // }
          // }
        }
      });
    };

    const menuItems = document.getElementsByTagName('a');
    // THIS MUST REMAIN "OF"
    for (const menu of menuItems) {
      menu.addEventListener("dragenter", (event) => {
        for (const list of lists) {
          list.style.display = 'none'
        }
        lists[event.target.dataset.day].style.display = 'flex';
      });

      menu.addEventListener("click", (event) => {
        for (const list of lists) {
          list.style.display = 'none'
        }
        lists[event.target.dataset.day].style.display = 'flex';
      });
    }

    const times = document.querySelectorAll("input[type=time]");
    // THIS MUST REMAIN "OF"
    for (const time of times) {
      time.addEventListener("change", (event) => {

        // Get the node for our listItem head. This contains the name of the site
        // and will help identify which node we are later
        let ourListItemHead = event.target.parentElement.children[0]
        
        // time input -> listItem -> list -> all listItems of list (ordered)
        let siblingListItems = event.target.parentElement.parentElement.children

        // Search through all our sibling nodes to find our current index
        // in the siblingListItems array
        let currentIndex = 0
        let ourIndex
        for (const listItem of siblingListItems) {
          if (listItem.children[0].isEqualNode(ourListItemHead)) {
            ourIndex = currentIndex
          }
          currentIndex++
        }

        // Change the time of the closest sibling depending on if the user
        // changes the beginning or ending time
        // TODO Check if the duration of the changed sibling is still positive, if not change color
        if (event.target.className == "begin") {
          if (siblingListItems[ourIndex-1]) {
            siblingListItems[ourIndex-1].children[2].value = event.target.value
          }
        } else {
          if (siblingListItems[ourIndex+1]) {
            siblingListItems[ourIndex+1].children[1].value = event.target.value
          }
        }

        // Check that the duration of any event is positive
        if (event.target.className == "begin") {
          if (parseInt(event.target.value.replace(/:/, "")) > parseInt(event.target.parentElement.children[2].value.replace(/:/, ""))) {
            event.target.parentElement.style.background = "#686868"
          } else {
            event.target.parentElement.style.background = "#FCAEAE"
          }
        } else {
          if (parseInt(event.target.value.replace(/:/, "")) < parseInt(event.target.parentElement.children[1].value.replace(/:/, ""))) {
            event.target.parentElement.style.background = "#686868"
          } else {
            event.target.parentElement.style.background = "#FCAEAE"
          }
        }

      });
    }

    const closes = document.getElementsByClassName('close');
    // THIS MUST REMAIN "OF"
    for (const close of closes) {
      close.addEventListener("click", (event) => {
        event.target.parentElement.children[0].innerHTML = "Free Time"
        event.target.parentElement.parentElement.children[3].innerHTML = "Do whatever you want"
      });
    }


    // TODO
    // On drop, choose between 3 options:
      // Don't change times, shift earlier sites by duration, shift later sites by duration
    // Can't drag to different days on iOS (try other elements/sizes???)
      // Can we make the daypicker a bit pretty as well

    // TODO
    // Give option for creating Free Time or shifting listItem
    // All our JS is based on very positional arguments. This is likely very brittle
      // We should switch to something better for maintainability
    // Have some sort of effect for when drag starts (on mobile)
    // Store state in URL
      // Sortable has built in ways to manage state!
      // https://github.com/SortableJS/Sortable#store
    // Consider travel times to and from the hotel
    // If the JS gets very complex, would a framework like Svelte/kit help?
      
    // KNOWN BUGS
    // We don't account for events that split between multiple days (e.g. 11pm-1am)
      // Well we could just handle them on the day they start. That is totally fine
      // But we have some calculations currently assuming all times are on the same day
    </script>
</body>
</html>