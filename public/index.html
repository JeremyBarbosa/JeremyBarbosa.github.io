<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>JHJ TRVLPLNNR</title>
  <style>
    body {
      margin: 0.5rem;
      /* TODO We can pick a prettier font */
      font: 1.25rem/1.5 sans-serif;
      text-rendering: optimizeSpeed;
      background: #FFEADD;
    }
    .list {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .listItem {
      /* TODO The background being a photo of the attraction is also possible,
      but care should be taken to make sure the text is still legible */
      background: #FCAEAE;
      border-radius: 0.5rem;
      border: solid #FF8989;
      padding: 0.5rem;
      /* TODO Make height proportional to lengh, shrink and grow as needed */
      /* Probs sizing per 30min, floored */
      overflow: hidden;
      min-height: 3rem;
      /* cursor: move; */
    }
    .listItem > *, h4 {
      margin: 0;
    }
    .head {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    p {
      font-size: 1rem;
    }
    input[type=time] {
      border: none;
      background: #FF8989;
      color: white;
      border-radius: 0.2rem;
      padding: 0;
    }
    #daypicker {
      /* Do I need to remove the display flex if we have more days? */
      display: flex;
      justify-content: space-between;
      background-color: #FF8989;
      border-radius: 0.5rem;
      margin-bottom: 1rem;
      overflow: auto;
      white-space: nowrap;
    }
    #daypicker a {
      display: inline-block;
      cursor: pointer;
      color: white;
      text-align: center;
      padding: 14px;
      text-decoration: none;
    }
    #daypicker a:hover {
      background-color: #777;
    }
    h4, span {
      line-height: normal;
    }
    .close {
      cursor: pointer;
    }
  </style>
</head>
<body>
  <header>
    <h1 style="font-size: 10vw; color: #FF6666; text-align: center; margin: 0;">Travel Planner</h1>
  </header>
  
  
  <script src="/Sortable.min.js"></script>
  <script>
    // let state = fetch("/itineraries/paris/3day.json")
    // .then(res => res.json())

    // We search for a lot of nodes, so do that all here in one go
    // document.querySelectorAll("input[type=time]");

    const lists = document.getElementsByClassName('list');
    // THIS MUST REMAIN "OF"
    for (const list of lists) {
      Sortable.create(list, {
        group: 'list',
        delay: 400,
        // We really only need delay on mobile to allow dragging
        // and this works around a bug that prevents delays on Edge
        delayOnTouchOnly: true,
        // Needed for delay on some sensitive touch screens
        touchStartThreshold: 3,
        // handle: '.handle',
        animation: 150,
      });
    };

    const menuItems = document.getElementsByTagName('a');
    // THIS MUST REMAIN "OF"
    for (const menu of menuItems) {
      menu.addEventListener("dragenter", (event) => {
        for (const list of lists) {
          list.style.display = 'none'
        }
        lists[event.target.dataset.day].style.display = 'flex';
      });

      menu.addEventListener("click", (event) => {
        for (const list of lists) {
          list.style.display = 'none'
        }
        lists[event.target.dataset.day].style.display = 'flex';
      });
    }

    const times = document.querySelectorAll("input[type=time]");
    // THIS MUST REMAIN "OF"
    for (const time of times) {
      time.addEventListener("change", (event) => {

        // Get the node for our listItem head. This contains the name of the site
        // and will help identify which node we are later
        let ourListItemHead = event.target.parentElement.children[0]
        
        // time input -> listItem -> list -> all listItems of list (ordered)
        let siblingListItems = event.target.parentElement.parentElement.children

        // Search through all our sibling nodes to find our current index
        // in the siblingListItems array
        let currentIndex = 0
        let ourIndex
        for (const listItem of siblingListItems) {
          if (listItem.children[0].isEqualNode(ourListItemHead)) {
            ourIndex = currentIndex
          }
          currentIndex++
        }

        // Change the time of the closest sibling depending on if the user
        // changes the beginning or ending time
        if (event.target.className == "begin") {
          if (siblingListItems[ourIndex-1]) {
            siblingListItems[ourIndex-1].children[2].value = event.target.value
          }
        } else {
          if (siblingListItems[ourIndex+1]) {
            siblingListItems[ourIndex+1].children[1].value = event.target.value
          }
        }

        // Check that the duration of any event is positive
        if (event.target.className == "begin") {
          if (parseInt(event.target.value.replace(/:/, "")) > parseInt(event.target.parentElement.children[2].value.replace(/:/, ""))) {
            event.target.parentElement.style.background = "#686868"
          } else {
            event.target.parentElement.style.background = "#FCAEAE"
          }
        } else {
          if (parseInt(event.target.value.replace(/:/, "")) < parseInt(event.target.parentElement.children[1].value.replace(/:/, ""))) {
            event.target.parentElement.style.background = "#686868"
          } else {
            event.target.parentElement.style.background = "#FCAEAE"
          }
        }

      });
    }

    const closes = document.getElementsByClassName('close');
    // THIS MUST REMAIN "OF"
    for (const close of closes) {
      close.addEventListener("click", (event) => {
        event.target.parentElement.children[0].innerHTML = "Free Time"
        event.target.parentElement.parentElement.children[3].innerHTML = "Do whatever you want"
      });
    }

    // TODO
    // On pickup, replace the original spot with a 'Free Time'
      // Actually you may want to create the free time when you drop the item
      // This way there are not a billion dupes
    // On drop, choose between 3 options:
      // Don't change times, shift earlier sites by duration, shift later sites by duration

    // TODO
    // Consider travel times to and from the hotel
    // Store state in URL

    // KNOWN BUGS
    // Can't drag to different days on iOS
    // We don't account for events that split between multiple days (e.g. 11pm-1am)
      // Well we could just handle them on the day they start. That is totally fine
      // But we have some calculations currently assuming all times are on the same day
    </script>
</body>
</html>